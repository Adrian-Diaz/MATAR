<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.4" xml:lang="en-US">
  <compounddef id="md_src__kokkos_kokkos__spack" kind="page">
    <compoundname>md_src_Kokkos_kokkos_Spack</compoundname>
    <title>Spack</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><image type="html" name="https://avatars2.githubusercontent.com/u/10199860?s=200&amp;v=4" alt="Kokkos" inline="yes"></image>
</para>
<sect1 id="md_src__kokkos_kokkos__spack_1autotoc_md125">
<title>Kokkos Spack</title>
<para>This gives instructions for using Spack to install Kokkos and developing packages that depend on Kokkos.</para>
<sect2 id="md_src__kokkos_kokkos__spack_1autotoc_md126">
<title>Getting Started</title>
<para>Make sure you have downloaded <ulink url="https://github.com/spack/spack">Spack</ulink>. The easiest way to configure the Spack environment is: <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>source<sp/>spack/share/spack/setup-env.sh</highlight></codeline>
</programlisting> with other scripts available for other shells. You can display information about how to install packages with: <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>spack<sp/>info<sp/>kokkos</highlight></codeline>
</programlisting> This will print all the information about how to install Kokkos with Spack. For detailed instructions on how to use Spack, see the <ulink url="https://spack.readthedocs.io">User Manual</ulink>.</para>
</sect2>
<sect2 id="md_src__kokkos_kokkos__spack_1autotoc_md127">
<title>Setting Up Spack: Avoiding the Package Cascade</title>
<para>By default, Spack doesn&apos;t &apos;see&apos; anything on your system - including things like CMake and CUDA. This can be limited by adding a <computeroutput>packages.yaml</computeroutput> to your <computeroutput>$HOME/.spack</computeroutput> folder that includes CMake (and CUDA, if applicable). For example, your <computeroutput>packages.yaml</computeroutput> file could be: <programlisting filename=".yaml"><codeline><highlight class="normal">packages:</highlight></codeline>
<codeline><highlight class="normal"><sp/>cuda:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>modules:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>cuda@10.1.243:<sp/>[cuda/10.1.243]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>paths:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>cuda@10.1.243:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>/opt/local/ppc64le-pwr8-nvidia/cuda/10.1.243</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>buildable:<sp/>false</highlight></codeline>
<codeline><highlight class="normal"><sp/>cmake:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>modules:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>cmake:<sp/>[cmake/3.16.8]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>paths:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>cmake:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>/opt/local/ppc64le/cmake/3.16.8</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>buildable:<sp/>false</highlight></codeline>
</programlisting> The <computeroutput>modules</computeroutput> entry is only necessary on systems that require loading Modules (i.e. most DOE systems). The <computeroutput>buildable</computeroutput> flag is useful to make sure Spack crashes if there is a path error, rather than having a type-o and Spack rebuilding everything because <computeroutput>cmake</computeroutput> isn&apos;t found. You can verify your environment is set up correctly by running <computeroutput>spack graph</computeroutput> or <computeroutput>spack spec</computeroutput>. For example: <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>spack<sp/>graph<sp/>kokkos<sp/>+cuda</highlight></codeline>
<codeline><highlight class="normal">o<sp/><sp/>kokkos</highlight></codeline>
<codeline><highlight class="normal">|\</highlight></codeline>
<codeline><highlight class="normal">o<sp/>|<sp/><sp/>cuda</highlight></codeline>
<codeline><highlight class="normal"><sp/>/</highlight></codeline>
<codeline><highlight class="normal">o<sp/><sp/>cmake</highlight></codeline>
</programlisting> Without the existing CUDA and CMake being identified in <computeroutput>packages.yaml</computeroutput>, a (subset!) of the output would be: <programlisting filename=".bash"><codeline><highlight class="normal">o<sp/><sp/>kokkos</highlight></codeline>
<codeline><highlight class="normal">|\</highlight></codeline>
<codeline><highlight class="normal">|<sp/>o<sp/><sp/>cmake</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|\</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|\</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|\</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|\</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|\</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>o<sp/>|<sp/>|<sp/>|<sp/><sp/>libarchive</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|\<sp/>\<sp/>\<sp/>\</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|\<sp/>\<sp/>\<sp/>\</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|_|/</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|/|<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>o<sp/><sp/>curl</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|_|_|_|_|_|_|_|_|_|_|/|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|/|<sp/>|<sp/>|<sp/>|_|_|_|_|_|_|_|/</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|/|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>o<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/>openssl</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|/|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>o<sp/>|<sp/>|<sp/><sp/>libxml2</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|_|_|_|_|_|_|_|/|<sp/>|<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|\<sp/>\<sp/>\</highlight></codeline>
<codeline><highlight class="normal">|<sp/>o<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/>zlib</highlight></codeline>
<codeline><highlight class="normal">|<sp/><sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/</highlight></codeline>
<codeline><highlight class="normal">|<sp/>o<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/>xz</highlight></codeline>
<codeline><highlight class="normal">|<sp/><sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/</highlight></codeline>
<codeline><highlight class="normal">|<sp/>o<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/>rhash</highlight></codeline>
<codeline><highlight class="normal">|<sp/><sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>o<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/>nettle</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|\<sp/>\<sp/>\<sp/>\<sp/>\<sp/>\<sp/>\</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>o<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/>libuv</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>o<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/>autoconf</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|_|/|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>|<sp/>|<sp/>|<sp/>|/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/<sp/>/</highlight></codeline>
<codeline><highlight class="normal">|<sp/>o<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/>perl</highlight></codeline>
<codeline><highlight class="normal">|<sp/>o<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/>gdbm</highlight></codeline>
<codeline><highlight class="normal">|<sp/>o<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/>readline</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_src__kokkos_kokkos__spack_1autotoc_md128">
<title>Configuring Kokkos as a Project Dependency</title>
<para>Say you have a project &quot;SuperScience&quot; which needs to use Kokkos. In your <computeroutput>package.py</computeroutput> file, you would generally include something like: <programlisting filename=".py"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">SuperScience(CMakePackage):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>depends_on(</highlight><highlight class="stringliteral">&quot;kokkos&quot;</highlight><highlight class="normal">)</highlight></codeline>
</programlisting> Often projects want to tweak behavior when using certain features, e.g. <programlisting filename=".py"><codeline><highlight class="normal">depends_on(</highlight><highlight class="stringliteral">&quot;kokkos+cuda&quot;</highlight><highlight class="normal">,<sp/>when=</highlight><highlight class="stringliteral">&quot;+cuda&quot;</highlight><highlight class="normal">)</highlight></codeline>
</programlisting> if your project needs CUDA-specific logic to configure and build. This illustrates the general principle in Spack of &quot;flowing-up&quot;. A user requests a feature in the final app: <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>spack<sp/>install<sp/>superscience+cuda</highlight></codeline>
</programlisting> This flows upstream to the Kokkos dependency, causing the <computeroutput>kokkos+cuda</computeroutput> variant to build. The downstream app (SuperScience) tells the upstream app (Kokkos) how to build.</para>
<para>Because Kokkos is a performance portability library, it somewhat inverts this principle. Kokkos &quot;flows-down&quot;, telling your application how best to configure for performance. Rather than a downstream app (SuperScience) telling the upstream (Kokkos) what variants to build, a pre-built Kokkos should be telling the downstream app SuperScience what variants to use. Kokkos works best when there is an &quot;expert&quot; configuration installed on your system. Your build should simply request <computeroutput>-DKokkos_ROOT=&lt;BEST_KOKKOS_FOR_MY_SYSTEM&gt;</computeroutput> and configure appropriately based on the Kokkos it finds.</para>
<para>Kokkos has many, many build variants. Where possible, projects should only depend on a general Kokkos, not specific variants. We recommend instead adding for each system you build on a Kokkos configuration to your <computeroutput>packages.yaml</computeroutput> file (usually found in <computeroutput>~/.spack</computeroutput> for specific users). For a Xeon + Volta system, this could look like: <programlisting filename=".yaml"><codeline><highlight class="normal">kokkos:</highlight></codeline>
<codeline><highlight class="normal"><sp/>variants:<sp/>+cuda<sp/>+openmp<sp/>+cuda_lambda<sp/>+wrapper<sp/>^cuda@10.1<sp/>cuda_arch=70</highlight></codeline>
<codeline><highlight class="normal"><sp/>compiler:<sp/>[gcc@7.2.0]</highlight></codeline>
</programlisting> which gives the &quot;best&quot; Kokkos configuration as CUDA+OpenMP optimized for a Volta 70 architecture using CUDA 10.1. It also enables support for CUDA Lambdas. The <computeroutput>+wrapper</computeroutput> option tells Kokkos to build with the special <computeroutput>nvcc_wrapper</computeroutput> (more below). Note here that we use the built-in <computeroutput>cuda_arch</computeroutput> variant of Spack to specify the archicture. For a Haswell system, we use <programlisting filename=".yaml"><codeline><highlight class="normal">kokkos:</highlight></codeline>
<codeline><highlight class="normal"><sp/>variants:<sp/>+openmp<sp/>std=14<sp/>target=haswell</highlight></codeline>
<codeline><highlight class="normal"><sp/>compiler:<sp/>[intel@18]</highlight></codeline>
</programlisting> which uses the built-in microarchitecture variants of Spack. Consult the Spack documentation for more details of Spack microarchitectures and CUDA architectures. Spack does not currently provide an AMD GPU microarchitecture option. If building for HIP or an AMD GPU, Kokkos provides an <computeroutput>amd_gpu_arch</computeroutput> similar to <computeroutput>cuda_arch</computeroutput>. <programlisting filename=".yaml"><codeline><highlight class="normal">kokkos:</highlight></codeline>
<codeline><highlight class="normal"><sp/>variants:<sp/>+hip<sp/>amd_gpu_arch=vega900</highlight></codeline>
</programlisting></para>
<para>Without an optimal default in your <computeroutput>packages.yaml</computeroutput> file, it is highly likely that the default Kokkos configuration you get will not be what you want. For example, CUDA is not enabled by default (there is no easy logic to conditionally activate this for CUDA-enabled systems). If you don&apos;t specify a CUDA build variant in a <computeroutput>packages.yaml</computeroutput> and you build your Kokkos-dependent project: <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>spack<sp/>install<sp/>superscience</highlight></codeline>
</programlisting> you may end up just getting the default Kokkos (i.e. Serial). Some examples are included in the <computeroutput>config/yaml</computeroutput> folder for common platforms. Before running <computeroutput>spack install &lt;package&gt;</computeroutput> we recommend running <computeroutput>spack spec &lt;package&gt;</computeroutput> to confirm your dependency tree is correct. For example, with Kokkos Kernels: <programlisting filename=".bash"><codeline><highlight class="normal">kokkos-kernels@3.0%gcc@8.3.0~blas<sp/>build_type=RelWithDebInfo<sp/>~cblas~complex_double~complex_float~cublas~cuda<sp/>cuda_arch=none<sp/>~cusparse~diy+double<sp/>execspace_cuda=auto<sp/>execspace_openmp=auto<sp/>execspace_serial=auto<sp/>execspace_threads=auto<sp/>~float~lapack~lapacke+layoutleft~layoutright<sp/>memspace_cudaspace=auto<sp/>memspace_cudauvmspace=auto<sp/>+memspace_hostspace~mkl+offset_int+offset_size_t~openmp+ordinal_int~ordinal_int64_t~serial~superlu<sp/>arch=linux-rhel7-skylake_avx512</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>^cmake@3.16.2%gcc@8.3.0~doc+ncurses+openssl+ownlibs~qt<sp/>arch=linux-rhel7-skylake_avx512</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>^kokkos@3.0%gcc@8.3.0~aggressive_vectorization~amdavx~armv80~armv81~armv8_thunderx~armv8_tx2~bdw~bgq<sp/>build_type=RelWithDebInfo<sp/>~carrizo~compiler_warnings+cuda<sp/>cuda_arch=none<sp/>+cuda_lambda~cuda_ldg_intrinsic~cuda_relocatable_device_code~cuda_uvm~debug~debug_bounds_check~debug_dualview_modify_check~deprecated_code~diy~epyc~examples~explicit_instantiation~fiji~gfx901~hpx~hpx_async_dispatch~hsw~hwloc~kaveri~kepler30~kepler32~kepler35~kepler37~knc~knl~maxwell50~maxwell52~maxwell53~memkind~numactl+openmp~pascal60~pascal61~power7~power8~power9+profiling~profiling_load_print~pthread~qthread~rocm~ryzen~serial~skx~snb<sp/>std=14<sp/>~tests~turing75~vega+volta70~volta72+wrapper~wsm<sp/>arch=linux-rhel7-skylake_avx512</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>^cuda@10.1%gcc@8.3.0<sp/>arch=linux-rhel7-skylake_avx512</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>^kokkos-nvcc-wrapper@old%gcc@8.3.0<sp/>build_type=RelWithDebInfo<sp/>+mpi<sp/>arch=linux-rhel7-skylake_avx512</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>^openmpi@4.0.2%gcc@8.3.0~cuda+cxx_exceptions<sp/>fabrics=none<sp/>~java~legacylaunchers~memchecker<sp/>patches=073477a76bba780c67c36e959cd3ee6910743e2735c7e76850ffba6791d498e4<sp/>~pmi<sp/>schedulers=none<sp/>~sqlite3~thread_multiple+vt<sp/>arch=linux-rhel7-skylake_avx512</highlight></codeline>
</programlisting> The output can be very verbose, but we can verify the expected <computeroutput>kokkos</computeroutput>: <programlisting filename=".bash"><codeline><highlight class="normal">kokkos@3.0%gcc@8.3.0~aggressive_vectorization~amdavx~armv80~armv81~armv8_thunderx~armv8_tx2~bdw~bgq<sp/>build_type=RelWithDebInfo<sp/>~carrizo~compiler_warnings+cuda<sp/>cuda_arch=none<sp/>+cuda_lambda~cuda_ldg_intrinsic~cuda_relocatable_device_code~cuda_uvm~debug~debug_bounds_check~debug_dualview_modify_check~deprecated_code~diy~epyc~examples~explicit_instantiation~fiji~gfx901~hpx~hpx_async_dispatch~hsw~hwloc~kaveri~kepler30~kepler32~kepler35~kepler37~knc~knl~maxwell50~maxwell52~maxwell53~memkind~numactl+openmp~pascal60~pascal61~power7~power8~power9+profiling~profiling_load_print~pthread~qthread~rocm~ryzen~serial~skx~snb<sp/>std=11<sp/>~tests~turing75~vega+volta70~volta72+wrapper~wsm<sp/>arch=linux-rhel7-skylake_avx512</highlight></codeline>
</programlisting> We see that we do have <computeroutput>+volta70</computeroutput> and <computeroutput>+wrapper</computeroutput>, e.g.</para>
<sect3 id="md_src__kokkos_kokkos__spack_1autotoc_md129">
<title>Spack Environments</title>
<para>The encouraged way to use Spack is with Spack environments (<ulink url="https://spack-tutorial.readthedocs.io/en/latest/tutorial_environments.html#dealing-with-many-specs-at-once">more details here</ulink>). Rather than installing packages one-at-a-time, you add packages to an environment. After adding all packages, you concretize and install them all. Using environments, one can explicitly add a desired Kokkos for the environment, e.g. <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>spack<sp/>add<sp/>kokkos<sp/>+cuda<sp/>+cuda_lambda<sp/>+volta70</highlight></codeline>
<codeline><highlight class="normal">&gt;<sp/>spack<sp/>add<sp/>my_project<sp/>+my_variant</highlight></codeline>
<codeline><highlight class="normal">&gt;<sp/>...</highlight></codeline>
<codeline><highlight class="normal">&gt;<sp/>spack<sp/>install</highlight></codeline>
</programlisting> All packages within the environment will build against the CUDA-enabled Kokkos, even if they only request a default Kokkos.</para>
</sect3>
</sect2>
<sect2 id="md_src__kokkos_kokkos__spack_1autotoc_md130">
<title>NVCC Wrapper</title>
<para>Kokkos is a C++ project, but often builds for the CUDA backend. This is particularly problematic with CMake. At this point, <computeroutput>nvcc</computeroutput> does not accept all the flags that normally get passed to a C++ compiler. Kokkos provides <computeroutput>nvcc_wrapper</computeroutput> that identifies correctly as a C++ compiler to CMake and accepts C++ flags, but uses <computeroutput>nvcc</computeroutput> as the underlying compiler. <computeroutput>nvcc</computeroutput> itself also uses an underlying host compiler, e.g. GCC.</para>
<para>In Spack, the underlying host compiler is specified as below, e.g.: <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>spack<sp/>install<sp/>package<sp/>%gcc@8.0.0</highlight></codeline>
</programlisting> This is still valid for Kokkos. To use the special wrapper for CUDA builds, request a desired compiler and simply add the <computeroutput>+wrapper</computeroutput> variant. <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>spack<sp/>install<sp/>kokkos<sp/>+cuda<sp/>+wrapper<sp/>%gcc@7.2.0</highlight></codeline>
</programlisting> Downstream projects depending on Kokkos need to override their compiler. Kokkos provides the compiler in a <computeroutput>kokkos_cxx</computeroutput> variable, which points to either <computeroutput>nvcc_wrapper</computeroutput> when needed or the regular compiler otherwise. Spack projects already do this to use MPI compiler wrappers. <programlisting filename=".py"><codeline><highlight class="keyword">def<sp/></highlight><highlight class="normal">cmake_args(self):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>options<sp/>=<sp/>[]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>options.append(</highlight><highlight class="stringliteral">&quot;-DCMAKE_CXX_COMPILER=%s&quot;</highlight><highlight class="normal"><sp/>%<sp/>self.spec[</highlight><highlight class="stringliteral">&quot;kokkos&quot;</highlight><highlight class="normal">].kokkos_cxx)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>options</highlight></codeline>
</programlisting> Note: <computeroutput>nvcc_wrapper</computeroutput> works with the MPI compiler wrappers. If building your project with MPI, do NOT set your compiler to <computeroutput>nvcc_wrapper</computeroutput>. Instead set your compiler to <computeroutput>mpicxx</computeroutput> and <computeroutput>nvcc_wrapper</computeroutput> will be used under the hood. <programlisting filename=".py"><codeline><highlight class="keyword">def<sp/></highlight><highlight class="normal">cmake_args(self):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>options<sp/>=<sp/>[]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>options.append(</highlight><highlight class="stringliteral">&quot;-DCMAKE_CXX_COMPILER=%s&quot;</highlight><highlight class="normal"><sp/>%<sp/>self.spec[</highlight><highlight class="stringliteral">&quot;mpi&quot;</highlight><highlight class="normal">].mpicxx)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>options</highlight></codeline>
</programlisting> To accomplish this, <computeroutput>nvcc_wrapper</computeroutput> must depend on MPI (even though it uses no MPI). This has the unfortunate consequence that Kokkos CUDA projects not using MPI will implicitly depend on MPI anyway. This behavior is necessary for now, but will hopefully be removed later. When using environments, if MPI is not needed, you can remove the MPI dependency with: <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>spack<sp/>add<sp/>kokkos-nvcc-wrapper<sp/>~mpi</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_src__kokkos_kokkos__spack_1autotoc_md131">
<title>Developing With Spack</title>
<para>Spack has historically been much more suited to <emphasis>deployment</emphasis> of mature packages than active testing or developing. However, recent features have improved support for development. Future releases are likely to make this even easier and incorporate Git integration. The most common commands will do a full build and install of the packages. If doing development, you may wish to merely set up a build environment. This allows you to modify the source and re-build. In this case, you can stop after configuring. Suppose you have Kokkos checkout in the folder <computeroutput>kokkos-src</computeroutput>: <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>spack<sp/>dev-build<sp/>-d<sp/>kokkos-src<sp/>-u<sp/>cmake<sp/>kokkos@develop<sp/>+wrapper<sp/>+openmp</highlight></codeline>
</programlisting> This sets up a development environment for you in <computeroutput>kokkos-src</computeroutput> which you can use (Bash example shown): Note: Always specify <computeroutput>develop</computeroutput> as the version when doing <computeroutput>dev-build</computeroutput>, except in rare cases. You are usually developing a feature branch that will merge into <computeroutput>develop</computeroutput>, hence you are making a new <computeroutput>develop</computeroutput> branch.</para>
<para><programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>cd<sp/>kokko-src</highlight></codeline>
<codeline><highlight class="normal">&gt;<sp/>source<sp/>spack-build-env.txt</highlight></codeline>
<codeline><highlight class="normal">&gt;<sp/>cd<sp/>spack-build</highlight></codeline>
<codeline><highlight class="normal">&gt;<sp/>make</highlight></codeline>
</programlisting> Before sourcing the Spack development environment, you may wish to save your current environment: <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>declare<sp/>-px<sp/>&gt;<sp/>myenv.sh</highlight></codeline>
</programlisting> When done with Spack, you can then restore your original environment: <programlisting filename=".bash"><codeline><highlight class="normal">&gt;<sp/>source<sp/>myenv.sh</highlight></codeline>
</programlisting> </para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="src/Kokkos/kokkos/Spack.md"/>
  </compounddef>
</doxygen>
