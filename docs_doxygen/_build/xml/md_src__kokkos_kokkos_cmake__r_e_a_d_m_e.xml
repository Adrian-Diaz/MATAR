<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.4" xml:lang="en-US">
  <compounddef id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e" kind="page">
    <compoundname>md_src_Kokkos_kokkos_cmake_README</compoundname>
    <title>README</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><image type="html" name="https://avatars2.githubusercontent.com/u/10199860?s=200&amp;v=4" alt="Kokkos" inline="yes"></image>
</para>
<sect1 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md62">
<title>Developing Kokkos</title>
<para>This document contains a build system overview for developers with information on adding new CMake options that could influence<itemizedlist>
<listitem><para>Header configuration macros</para>
</listitem><listitem><para>Optional features</para>
</listitem><listitem><para>Third-partly libraries</para>
</listitem><listitem><para>Compiler and linker flags For build system details for users, refer to the <ref refid="md_src__kokkos_kokkos__b_u_i_l_d" kindref="compound">build instructions</ref>.</para>
</listitem></itemizedlist>
</para>
<sect2 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md63">
<title>Build System</title>
<para>Kokkos uses CMake to configure, build, and install. Rather than being a completely straightforward use of modern CMake, Kokkos has several extra complications, primarily due to:<itemizedlist>
<listitem><para>Kokkos must support linking to an installed version or in-tree builds as a subdirectory of a larger project.</para>
</listitem><listitem><para>Kokkos must configure a special compiler <computeroutput>nvcc_wrapper</computeroutput> that allows <computeroutput>nvcc</computeroutput> to accept all C++ flags (which <computeroutput>nvcc</computeroutput> currently does not).</para>
</listitem><listitem><para>Kokkos must work as a part of TriBITS, a CMake library providing a particular build idiom for Trilinos.</para>
</listitem><listitem><para>Kokkos has many pre-existing users. We need to be careful about breaking previous versions or generating meaningful error messags if we do break backwards compatibility.</para>
</listitem></itemizedlist>
</para>
<para>If you are looking at the build system code wondering why certain decisions were made: we have had to balance many competing requirements and certain technical debt. Everything in the build system was done for a reason, trying to adhere as closely as possible to modern CMake best practices while meeting all pre-existing. customer requirements.</para>
<sect3 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md64">
<title>Modern CMake Philosophy</title>
<para>Modern CMake relies on understanding the principle of <emphasis>building</emphasis> and <emphasis>using</emphasis> a code project. What preprocessor, compiler, and linker flags do I need to <emphasis>build</emphasis> my project? What flags does a downstream project that links to me need to <emphasis>use</emphasis> my project? In CMake terms, flags that are only needed for building are <computeroutput>PRIVATE</computeroutput>. Only Kokkos needs these flags, not a package that depends on Kokkos. Flags that must be used in a downstream project are <computeroutput>PUBLIC</computeroutput>. Kokkos must tell other projects to use them.</para>
<para>In Kokkos, almost everything is a public flag since Kokkos is driven by headers and Kokkos is in charge of optimizing your code to achieve performance portability! Include paths, C++ standard flags, architecture-specific optimizations, or OpenMP and CUDA flags are all examples of flags that Kokkos configures and adds to your project.</para>
<para>Modern CMake now automatically propagates flags through the <computeroutput>target_link_libraries</computeroutput> command. Suppose you have a library <computeroutput>stencil</computeroutput> that needs to build with Kokkos. Consider the following CMake code:</para>
<para><programlisting><codeline><highlight class="normal">find_package(Kokkos)</highlight></codeline>
<codeline><highlight class="normal">add_library(stencil<sp/>stencil.cpp)</highlight></codeline>
<codeline><highlight class="normal">target_link_libraries(stencil<sp/>Kokkos::kokkos)</highlight></codeline>
</programlisting></para>
<para>This locates the Kokkos package, adds your library, and tells CMake to link Kokkos to your library. All public build flags get added automatically through the <computeroutput>target_link_libraries</computeroutput> command. There is nothing to do. You can be happily oblivious to how Kokkos was configured. Everything should just work.</para>
<para>As a Kokkos developer who wants to add new public compiler flags, how do you ensure that CMake does this properly? Modern CMake works through targets and properties. Each target has a set of standard properties:<itemizedlist>
<listitem><para><computeroutput>INTERFACE_COMPILE_OPTIONS</computeroutput> contains all the compiler options that Kokkos should add to downstream projects</para>
</listitem><listitem><para><computeroutput>INTERFACE_INCLUDE_DIRECTORIES</computeroutput> contains all the directories downstream projects must include from Kokkos</para>
</listitem><listitem><para><computeroutput>INTERFACE_COMPILE_DEFINITIONS</computeroutput> contains the list of preprocessor <computeroutput>-D</computeroutput> flags</para>
</listitem><listitem><para><computeroutput>INTERFACE_LINK_LIBRARIES</computeroutput> contains all the libraries downstream projects need to link</para>
</listitem><listitem><para><computeroutput>INTERFACE_COMPILE_FEATURES</computeroutput> essentially adds compiler flags, but with extra complications. Features names are specific to CMake. More later.</para>
</listitem></itemizedlist>
</para>
<para>CMake makes it easy to append to these properties using:<itemizedlist>
<listitem><para><computeroutput>target_compile_options(kokkos PUBLIC -fmyflag)</computeroutput></para>
</listitem><listitem><para><computeroutput>target_include_directories(kokkos PUBLIC mySpecialFolder)</computeroutput></para>
</listitem><listitem><para><computeroutput>target_compile_definitions(kokkos PUBLIC -DmySpecialFlag=0)</computeroutput></para>
</listitem><listitem><para><computeroutput>target_link_libraries(kokkos PUBLIC mySpecialLibrary)</computeroutput></para>
</listitem><listitem><para><computeroutput>target_compile_features(kokkos PUBLIC mySpecialFeature)</computeroutput> Note that all of these use <computeroutput>PUBLIC</computeroutput>! Almost every Kokkos flag is not private to Kokkos, but must also be used by downstream projects.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md65">
<title>Compiler Features and Compiler Options</title>
<para>Compiler options are flags like <computeroutput>-fopenmp</computeroutput> that do not need to be &quot;resolved.&quot; The flag is either on or off. Compiler features are more fine-grained and require conflicting requests to be resolved. Suppose I have <programlisting><codeline><highlight class="normal">add_library(A<sp/>a.cpp)</highlight></codeline>
<codeline><highlight class="normal">target_compile_features(A<sp/>PUBLIC<sp/>cxx_std_14)</highlight></codeline>
</programlisting> then another target <programlisting><codeline><highlight class="normal">add_library(B<sp/>b.cpp)</highlight></codeline>
<codeline><highlight class="normal">target_compile_features(B<sp/>PUBLIC<sp/>cxx_std_17)</highlight></codeline>
<codeline><highlight class="normal">target_link_libraries(A<sp/>B)</highlight></codeline>
</programlisting> I have requested two different features. CMake understands the requests and knows that <computeroutput>cxx_std_14</computeroutput> is a subset of <computeroutput>cxx_std_17</computeroutput>. CMake then picks C++17 for library <computeroutput>B</computeroutput>. CMake would not have been able to do feature resolution if we had directly done: <programlisting><codeline><highlight class="normal">target_compile_options(A<sp/>PUBLIC<sp/>-std=c++14)</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md66">
<title>Adding Kokkos Options</title>
<para>After configuring for the first time, CMake creates a cache of configure variables in <computeroutput>CMakeCache.txt</computeroutput>. Reconfiguring in the folder &quot;restarts&quot; from those variables. All flags passed as <computeroutput>-DKokkos_SOME_OPTION=X</computeroutput> to <computeroutput>cmake</computeroutput> become variables in the cache. All Kokkos options begin with camel case <computeroutput>Kokkos_</computeroutput> followed by an upper case option name.</para>
<para>CMake best practice is to avoid cache variables, if possible. In essence, you want the minimal amount of state cached between configurations. And never, ever have behavior influenced by multiple cache variables. If you want to change the Kokkos configuration, have a single unique variable that needs to be changed. Never require two cache variables to be changed.</para>
<para>Kokkos provides a function <computeroutput>KOKKOS_OPTION</computeroutput> for defining valid cache-level variables, proofreading them, and defining local project variables. The most common variables are called <computeroutput>Kokkos_ENABLE_X</computeroutput>, for which a helper function <computeroutput>KOKKOS_ENABLE_OPTION</computeroutput> is provided, e.g. <programlisting><codeline><highlight class="normal">KOKKOS_ENABLE_OPTION(TESTS<sp/>OFF<sp/><sp/>&quot;Whether<sp/>to<sp/>build<sp/>tests&quot;)</highlight></codeline>
</programlisting> The function checks if <computeroutput>-DKokkos_ENABLE_TESTS</computeroutput> was given, whether it was given with the wrong case, e.g. <computeroutput>-DKokkos_Enable_Tests</computeroutput>, and then defines a regular (non-cache) variable <computeroutput>KOKKOS_ENABLE_TESTS</computeroutput> to <computeroutput>ON</computeroutput> or <computeroutput>OFF</computeroutput> depending on the given default and whether the option was specified.</para>
</sect3>
<sect3 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md67">
<title>Defining Kokkos Config Macros</title>
<para>Sometimes you may want to add <computeroutput>#define Kokkos_X</computeroutput> macros to the config header. This is straightforward with CMake. Suppose you want to define an optional macro <computeroutput>KOKKOS_SUPER_SCIENCE</computeroutput>. Simply go into <computeroutput>KokkosCore_config.h.in</computeroutput> and add <programlisting><codeline><highlight class="normal">#cmakedefine<sp/>KOKKOS_SUPER_SCIENCE</highlight></codeline>
</programlisting> I can either add <programlisting><codeline><highlight class="normal">KOKKOS_OPTION(SUPER_SCIENCE<sp/>ON<sp/>&quot;Whether<sp/>to<sp/>do<sp/>some<sp/>super<sp/>science&quot;)</highlight></codeline>
</programlisting> to directly set the variable as a command-line <computeroutput>-D</computeroutput> option. Alternatively, based on other logic, I could add to a <computeroutput>CMakeLists.txt</computeroutput> <programlisting><codeline><highlight class="normal">SET(KOKKOS_SUPER_SCIENCE<sp/>ON)</highlight></codeline>
</programlisting> If not set as a command-line option (cache variable), you must make sure the variable is visible in the top-level scope. If set in a function, you would need: <programlisting><codeline><highlight class="normal">SET(KOKKOS_SUPER_SCIENCE<sp/>ON<sp/>PARENT_SCOPE)</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md68">
<title>Third-Party Libraries</title>
<para>In much the same way that compiler flags transitively propagate to dependent projects, modern CMake allows us to propagate dependent libraries. If Kokkos depends on, e.g. <computeroutput>hwloc</computeroutput> the downstream project will also need to link <computeroutput>hwloc</computeroutput>. There are three stages in adding a new third-party library (TPL):<itemizedlist>
<listitem><para>Finding: find the desired library on the system and verify the installation is correct</para>
</listitem><listitem><para>Importing: create a CMake target, if necessary, that is compatible with <computeroutput>target_link_libraries</computeroutput>. This is mostly relevant for TPLs not installed with CMake.</para>
</listitem><listitem><para>Exporting: make the desired library visible to downstream projects</para>
</listitem></itemizedlist>
</para>
<para>TPLs are somewhat complicated by whether the library was installed with CMake or some other build system. If CMake, our lives are greatly simplified. We simply use <computeroutput>find_package</computeroutput> to locate the installed CMake project then call <computeroutput>target_link_libraries(kokkoscore PUBLIC/PRIVATE TPL)</computeroutput>. For libaries not installed with CMake, the process is a bit more complex. It is up to the Kokkos developers to &quot;convert&quot; the library into a CMake target as if it had been installed as a valid modern CMake target with properties. There are helper functions for simplifying the process of importing TPLs in Kokkos, but we walk through the process in detail to clearly illustrate the steps involved.</para>
<sect4 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md69">
<title>TPL Search Order</title>
<para>There are several options for where CMake could try to find a TPL. If there are multiple installations of the same TPL on the system, the search order is critical for making sure the correct TPL is found. There are 3 possibilities that could be used:</para>
<para><orderedlist>
<listitem><para>Default system paths like /usr</para>
</listitem></orderedlist>
<orderedlist>
<listitem><para>User-provided paths through options <computeroutput>&lt;NAME&gt;_ROOT</computeroutput> and <computeroutput>Kokkos_&lt;NAME&gt;_DIR</computeroutput></para>
</listitem></orderedlist>
<orderedlist>
<listitem><para>Additional paths not in the CMake default list or provided by the user that Kokkos decides to add. For example, Kokkos may query <computeroutput>nvcc</computeroutput> or <computeroutput>LD_LIBRARY_PATH</computeroutput> for where to find CUDA libraries.</para>
</listitem></orderedlist>
</para>
<para>The following is the search order that Kokkos follows. Note: This differs from the default search order used by CMake <computeroutput>find_library</computeroutput> and <computeroutput>find_header</computeroutput>. CMake prefers default system paths over user-provided paths. For Kokkos (and package managers in general), it is better to prefer user-provided paths since this usually indicates a specific version we want.</para>
<para><orderedlist>
<listitem><para><computeroutput>&lt;NAME&gt;_ROOT</computeroutput> command line option</para>
</listitem></orderedlist>
<orderedlist>
<listitem><para><computeroutput>&lt;NAME&gt;_ROOT</computeroutput> environment variable</para>
</listitem></orderedlist>
<orderedlist>
<listitem><para><computeroutput>Kokkos_&lt;NAME&gt;_DIR</computeroutput> command line option</para>
</listitem></orderedlist>
<orderedlist>
<listitem><para>Paths added by Kokkos CMake logic</para>
</listitem></orderedlist>
<orderedlist>
<listitem><para>Default system paths (if allowed)</para>
</listitem></orderedlist>
</para>
<para>Default system paths are allowed in two cases. First, none of the other options are given so the only place to look is system paths. Second, if explicitly given permission, configure will look in system paths. The rationale for this logic is that if you specify a custom location, you usually <emphasis>only</emphasis> want to look in that location. If you do not find the TPL where you expect it, you should error out rather than grab another random match.</para>
</sect4>
<sect4 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md70">
<title>Finding TPLs</title>
<para>If finding a TPL that is not a modern CMake project, refer to the <computeroutput>FindHWLOC.cmake</computeroutput> file in <computeroutput>cmake/Modules</computeroutput> for an example. You will usually need to verify expected headers with <computeroutput>find_path</computeroutput> <programlisting><codeline><highlight class="normal">find_path(TPL_INCLUDE_DIR<sp/>mytpl.h<sp/>PATHS<sp/>&quot;${KOKKOS_MYTPL_DIR}/include&quot;)</highlight></codeline>
</programlisting> This insures that the library header is in the expected include directory and defines the variable <computeroutput>TPL_INCLUDE_DIR</computeroutput> with a valid path if successful. Similarly, you can verify a library <programlisting><codeline><highlight class="normal">find_library(TPL_LIBRARY<sp/>mytpl<sp/>PATHS<sp/>&quot;${KOKKOS_MYTPL_DIR/lib&quot;)</highlight></codeline>
</programlisting> that then defines the variable <computeroutput>TPL_LIBRARY</computeroutput> with a valid path if successful. CMake provides a utility for checking if the <computeroutput>find_path</computeroutput> and <computeroutput>find_library</computeroutput> calls were successful that emulates the behavior of <computeroutput>find_package</computeroutput> for a CMake target. <programlisting><codeline><highlight class="normal">include(FindPackageHandleStandardArgs)</highlight></codeline>
<codeline><highlight class="normal">find_package_handle_standard_args(MYTPL<sp/>DEFAULT_MSG</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MYTPL_INCLUDE_DIR<sp/>MYTPL_LIBRARY)</highlight></codeline>
</programlisting> If the find failed, CMake will print standard error messages explaining the failure.</para>
</sect4>
<sect4 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md71">
<title>Importing TPLs</title>
<para>The installed TPL must be adapted into a CMake target. CMake allows libraries to be added that are built externally as follows: <programlisting><codeline><highlight class="normal">add_library(Kokkos::mytpl<sp/>UNKNOWN<sp/>IMPORTED)</highlight></codeline>
</programlisting> Importantly, we use a <computeroutput>Kokkos::</computeroutput> namespace to avoid name conflicts and identify this specifically as the version imported by Kokkos. Because we are importing a non-CMake target, we must populate all the target properties that would have been automatically populated for a CMake target. <programlisting><codeline><highlight class="normal">set_target_properties(Kokkos::mytpl<sp/>PROPERTIES</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INTERFACE_INCLUDE_DIRECTORIES<sp/>&quot;${MYTPL_INCLUDE_DIR}&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IMPORTED_LOCATION<sp/>&quot;${MYTPL_LIBRARY}&quot;</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
</programlisting></para>
</sect4>
<sect4 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md72">
<title>Exporting TPLs</title>
<para>Kokkos may now depend on the target <computeroutput>Kokkos::mytpl</computeroutput> as a <computeroutput>PUBLIC</computeroutput> library (remember building and using). This means that downstream projects must also know about <computeroutput>Kokkos::myptl</computeroutput> - so Kokkos must export them. In the <computeroutput>KokkosConfig.cmake.in</computeroutput> file, we need to add code like the following: <programlisting><codeline><highlight class="normal">set(MYTPL_LIBRARY<sp/>@MYTPL_LIBRARY@)</highlight></codeline>
<codeline><highlight class="normal">set(MYTPL_INCLUDE_DIR<sp/>@MYTPL_INCLUDE_DIR@)</highlight></codeline>
<codeline><highlight class="normal">add_library(Kokkos::mytpl<sp/>UNKNOWN<sp/>IMPORTED)</highlight></codeline>
<codeline><highlight class="normal">set_target_properties(Kokkos::mytpl<sp/>PROPERTIES</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>INTERFACE_INCLUDE_DIRECTORIES<sp/>&quot;${MYTPL_INCLUDE_DIR}&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IMPORTED_LOCATION<sp/>&quot;${MYTPL_LIBRARY}&quot;</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
</programlisting> If this looks familiar, that&apos;s because it is exactly the same code as above for importing the TPL. Exporting a TPL really just means importing the TPL when Kokkos is loaded by an external project. We will describe helper functions that simplify this process.</para>
</sect4>
<sect4 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md73">
<title>Interface TPLs</title>
<para>If a TPL is just a library and set of headers, we can make a simple <computeroutput>IMPORTED</computeroutput> target. However, a TPL is actually completely flexible and need not be limited to just headers and libraries. TPLs can configure compiler flags, linker flags, or multiple different libraries. For this, we use a special type of CMake target: <computeroutput>INTERFACE</computeroutput> libraries. These libraries don&apos;t build anything. They simply populate properties that will configure flags for dependent targets. We consider the example: <programlisting><codeline><highlight class="normal">add_library(PTHREAD<sp/>INTERFACE)</highlight></codeline>
<codeline><highlight class="normal">target_compile_options(PTHREAD<sp/>PUBLIC<sp/>-pthread)</highlight></codeline>
</programlisting> Kokkos uses the compiler flag <computeroutput>-pthread</computeroutput> to define compiler macros for re-entrant functions rather than treating it simply as a library with header <computeroutput>pthread.h</computeroutput> and library <computeroutput>-lpthread</computeroutput>. Any property can be configured, e.g. <programlisting><codeline><highlight class="normal">target_link_libraries(MYTPL<sp/>...)</highlight></codeline>
</programlisting> In contrast to imported TPLs which require direct modification of <computeroutput>KokkosConfig.cmake.in</computeroutput>, we can use CMake&apos;s built-in export functions: <programlisting><codeline><highlight class="normal">INSTALL(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>TARGETS<sp/>MYTPL</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPORT<sp/>KokkosTargets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>RUNTIME<sp/>DESTINATION<sp/>${CMAKE_INSTALL_BINDIR}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LIBRARY<sp/>DESTINATION<sp/>${CMAKE_INSTALL_LIBDIR}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ARCHIVE<sp/>DESTINATION<sp/>${CMAKE_INSTALL_LIBDIR}</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
</programlisting> These interface targets will be automatically populated in the config file.</para>
</sect4>
<sect4 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md74">
<title>Linking the TPL</title>
<para>After finishing the import process, it still remains to link the imported target as needed. For example, <programlisting><codeline><highlight class="normal">target_link_libraries(kokkoscore<sp/>PUBLIC<sp/>Kokkos::HWLOC)</highlight></codeline>
</programlisting> The complexity of which includes, options, and libraries the TPL requires should be encapsulated in the CMake target.</para>
</sect4>
<sect4 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md75">
<title>TPL Helper Functions</title>
<para><anchor id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md76"/> <heading level="5">KOKKOS_IMPORT_TPL</heading>
</para>
<para>This function can be invoked as, e.g. <programlisting><codeline><highlight class="normal">KOKKOS_IMPORT_TPL(HWLOC)</highlight></codeline>
</programlisting> This function checks if the TPL was enabled by a <computeroutput>-DKokkos_ENABLE_HWLOC=On</computeroutput> flag. If so, it calls <computeroutput>find_package(TPLHWLOC)</computeroutput>. This invokes the file <computeroutput>FindTPLHWLOC.cmake</computeroutput> which should be contained in the <computeroutput>cmake/Modules</computeroutput> folder. If successful, another function <computeroutput>KOKKOS_EXPORT_CMAKE_TPL</computeroutput> gets invoked. This automatically adds all the necessary import commands to <computeroutput>KokkosConfig.cmake</computeroutput>.</para>
<para><anchor id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md77"/> <heading level="5">KOKKOS_FIND_IMPORTED</heading>
</para>
<para>Inside a <computeroutput>FindTPLX.cmake</computeroutput> file, the simplest way to import a library is to call, e.g. <programlisting><codeline><highlight class="normal">KOKKOS_FIND_IMPORTED(HWLOC<sp/>LIBRARY<sp/>hwloc<sp/>HEADER<sp/>hwloc.h)</highlight></codeline>
</programlisting> This finds the location of the library and header and creates an imported target <computeroutput>Kokkos::HWLOC</computeroutput> that can be linked against. The library/header find can be guided with <computeroutput>-DHWLOC_ROOT=</computeroutput> or <computeroutput>-DKokkos_HWLOC_DIR=</computeroutput> during CMake configure. These both specify the install prefix.</para>
<para><anchor id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md78"/> <heading level="5">KOKKOS_LINK_TPL</heading>
</para>
<para>This function checks if the TPL has been enabled. If so, it links a given library against the imported (or interface) TPL target.</para>
<para><anchor id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md79"/> <heading level="5">KOKKOS_CREATE_IMPORTED_TPL</heading>
</para>
<para>This helper function is best understood by reading the actual code. This function takes arguments specifying the properties and creates the actual TPL target. The most important thing to understand for this function is whether you call this function with the optional <computeroutput>INTERFACE</computeroutput> keyword. This tells the project to either create the target as an imported target or interface target, as discussed above.</para>
<para><anchor id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md80"/> <heading level="5">KOKKOS_EXPORT_CMAKE_TPL</heading>
</para>
<para>Even if the TPL just loads a valid CMake target, we still must &quot;export&quot; it into the config file. When Kokkos is loaded by a downstream project, this TPL must be loaded. Calling this function simply appends text recording the location where the TPL was found and adding a <computeroutput>find_dependency(...)</computeroutput> call that will reload the CMake target.</para>
</sect4>
</sect3>
<sect3 id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md81">
<title>The Great TriBITS Compromise</title>
<para>TriBITS was a masterpiece of CMake version 2 before the modern CMake idioms of building and using. TriBITS greatly limited verbosity of CMake files, handled complicated dependency trees between packages, and handled automatically setting up include and linker paths for dependent libraries.</para>
<para>Kokkos is now used by numerous projects that don&apos;t (and won&apos;t) depend on TriBITS for their build systems. Kokkos has to work outside of TriBITS and provide a standard CMake 3+ build system. At the same time, Kokkos is used by numerous projects that depend on TriBITS and don&apos;t (and won&apos;t) switch to a standard CMake 3+ build system.</para>
<para>Instead of calling functions <computeroutput>TRIBITS_X(...)</computeroutput>, the CMake calls wrapper functions <computeroutput>KOKKOS_X(...)</computeroutput>. If TriBITS is available (as in Trilinos), <computeroutput>KOKKOS_X</computeroutput> will just be a thin wrapper around <computeroutput>TRIBITS_X</computeroutput>. If TriBITS is not available, Kokkos maps <computeroutput>KOKKOS_X</computeroutput> calls to native CMake that complies with CMake 3 idioms. For the time being, this seems the most sensible way to handle the competing requirements of a standalone modern CMake and TriBITS build system.</para>
<para><anchor id="md_src__kokkos_kokkos_cmake__r_e_a_d_m_e_1autotoc_md82"/> <heading level="5"><ulink url="https://github.com/kokkos/kokkos/blob/devel/LICENSE">LICENSE</ulink></heading>
</para>
<para><ulink url="https://opensource.org/licenses/BSD-3-Clause"><image type="html" name="https://img.shields.io/badge/License-BSD%203--Clause-blue.svg" alt="License" inline="yes"></image>
</ulink></para>
<para>Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software. </para>
</sect3>
</sect2>
</sect1>
    </detaileddescription>
    <location file="src/Kokkos/kokkos/cmake/README.md"/>
  </compounddef>
</doxygen>
