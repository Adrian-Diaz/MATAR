<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.4" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>MATAR</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1md__Users_calvinroth_paraNotes_MATAR_README"/></para>
<para><image type="html" name="https://github.com/lanl/MATAR/blob/main/MATAR_Logo.png" inline="yes"></image>
</para>
<para>MATAR is a C++ library that addresses the need for simple, fast, and memory-efficient multi-dimensional data representations for dense and sparse storage that arise with numerical methods and in software applications. The data representations are designed to perform well across multiple computer architectures, including CPUs and GPUs. MATAR allows users to easily create and use intricate data representations that are also portable across disparate architectures using Kokkos. The performance aspect is achieved by forcing contiguous memory layout (or as close to contiguous as possible) for multi-dimensional and multi-size dense or sparse MATrix and ARray (hence, MATAR) types. Results show that MATAR has the capability to improve memory utilization, performance, and programmer productivity in scientific computing. This is achieved by fitting more work into the available memory, minimizing memory loads required, and by loading memory in the most efficient order.</para>
<sect1 id="index_1autotoc_md1">
<title>Examples</title>
<para><itemizedlist>
<listitem><para><ulink url="https://github.com/lanl/ELEMENTS/">ELEMENTS</ulink>: MATAR is a part of the ELEMENTS Library (LANL C# C20058) and it underpins the routines implemented in ELEMENTS. MATAR is available in a stand-alone directory outside of the ELEMENTS directory because it can aid many code applications. The dense and sparse storage types in MATAR are the foundation for the ELEMENTS library, which contains mathematical functions to support a very broad range of element types including: linear, quadratic, and cubic serendipity elements in 2D and 3D; high-order spectral elements; and a linear 4D element. An unstructured high-order mesh class is available in ELEMENTS and it takes advantage of MATAR for efficient access of various mesh entities.</para>
</listitem><listitem><para><ulink url="https://github.com/lanl/Fierro">Fierro</ulink>: The MATAR library underpins the Fierro code that is designed to simulate quasi-static solid mechanics problems and material dynamics problems. <linebreak/>
</para>
</listitem><listitem><para>Simple examples are in the /test folder</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="index_1autotoc_md2">
<title>Descriptions</title>
<para><itemizedlist>
<listitem><para>All Array MATAR types (e.g., <ref refid="d1/dbe/class_c_array" kindref="compound">CArray</ref>, <ref refid="dc/dbd/class_view_c_array" kindref="compound">ViewCArray</ref>, <ref refid="de/d57/class_f_array" kindref="compound">FArray</ref>, <ref refid="d1/da3/class_ragged_right_array" kindref="compound">RaggedRightArray</ref>, etc.) start with an index of 0 and stop at an index of N-1, where N is the number of entries. <linebreak/>
</para>
</listitem><listitem><para>All Matrix MATAR types (e.g., <ref refid="d2/dcb/class_c_matrix" kindref="compound">CMatrix</ref>, <ref refid="d8/dad/class_view_c_matrix" kindref="compound">ViewCMatrix</ref>, <ref refid="dc/d2f/class_f_matrix" kindref="compound">FMatrix</ref>, etc.) start with an index of 1 and stop at an index of N, where N is the number of entries.</para>
</listitem><listitem><para>The MATAR View types (e.g., <ref refid="dc/dbd/class_view_c_array" kindref="compound">ViewCArray</ref>, <ref refid="d8/dad/class_view_c_matrix" kindref="compound">ViewCMatrix</ref>, <ref refid="de/d36/class_view_f_array" kindref="compound">ViewFArray</ref>, etc. ) are designed to accept a pointer to an existing 1D array and then access that 1D data as a multi-dimensional array. The MATAR View types can also be used to slice an existing View. <linebreak/>
</para>
</listitem><listitem><para>The C dense storage and View types (e.g., <ref refid="d1/dbe/class_c_array" kindref="compound">CArray</ref>, <ref refid="dc/dbd/class_view_c_array" kindref="compound">ViewCArray</ref>, <ref refid="d2/dcb/class_c_matrix" kindref="compound">CMatrix</ref>, etc.) access the data following the C/C++ language convection of having the last index in a multi-dimensional array vary the quickest. In a 2D <ref refid="d1/dbe/class_c_array" kindref="compound">CArray</ref> A, the index j in A(i,j) varies first followed by the index i, so the optimal performance is achieved using the following loop ordering. <programlisting><codeline><highlight class="normal">//<sp/>Optimal<sp/>use<sp/>of<sp/>CArray</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(i=0,i&lt;N,i++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(j=0,j&lt;N,j++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A(i,j)<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>The F dense storage and View types (e.g., <ref refid="de/d57/class_f_array" kindref="compound">FArray</ref>, <ref refid="de/d36/class_view_f_array" kindref="compound">ViewFArray</ref>, <ref refid="dc/d2f/class_f_matrix" kindref="compound">FMatrix</ref>, etc.) access the data following the Fortran language convection of having the first index in a multi-dimensional array vary the quickest. In a 2D <ref refid="dc/d2f/class_f_matrix" kindref="compound">FMatrix</ref> M, the index i in M(i,j) varies first followed by the index j, so the optimal performance is achieved using the following loop ordering.</para>
</listitem></itemizedlist>
</para>
<para><programlisting><codeline><highlight class="normal">//<sp/>Optimal<sp/>use<sp/>of<sp/>FMatrix</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(j=1,j&lt;=N,j++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i=1,i&lt;=N,i++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>M(i,j)<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><itemizedlist>
<listitem><para>The ragged data types (e.g., <ref refid="d1/da3/class_ragged_right_array" kindref="compound">RaggedRightArray</ref>, <ref refid="d1/d2d/class_ragged_down_array" kindref="compound">RaggedDownArray</ref>, etc) in MATAR are special sparse storage types. The Right access types are for R(i,j) where the number of column entries varies in width across the array. The Down access types are for D(i,j) where the number of row entries vary in length across the array.</para>
</listitem><listitem><para>The SparseRowArray MATAR type is the idetical to the Compressed Sparse Row (CSR) or Compressed Row Storage (CSR) respresentation.</para>
</listitem><listitem><para>The SparseColumnArray MATAR type is identical to the Compressed Sparse Column (CSC) or Compressed Column Storage (CCS) respresentation.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="index_1autotoc_md3">
<title>Usage</title>
<para><programlisting><codeline><highlight class="normal">//<sp/>create<sp/>a<sp/>1D<sp/>array<sp/>of<sp/>integers<sp/>and<sp/>then<sp/>access<sp/>as<sp/>a<sp/>2D<sp/>array</highlight></codeline>
<codeline><highlight class="normal">int<sp/>A[9];</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>A_array<sp/>=<sp/>ViewCArray<sp/>&lt;int&gt;<sp/>(A,<sp/>3,<sp/>3);<sp/>//<sp/>access<sp/>as<sp/>A(i,j)<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>create<sp/>a<sp/>3D<sp/>array<sp/>of<sp/>doubles</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>B<sp/>=<sp/>CArray<sp/>&lt;double&gt;<sp/>(3,3,3);<sp/>//<sp/>access<sp/>as<sp/>B(i,j,k)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>create<sp/>a<sp/>slice<sp/>of<sp/>the<sp/>3D<sp/>array<sp/>at<sp/>index<sp/>1</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>C<sp/>=<sp/>ViewCArray<sp/>&lt;double&gt;<sp/>(&amp;B(1,0,0),3,3);<sp/>//<sp/>access<sp/>as<sp/>C(j,k)</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>create<sp/>a<sp/>4D<sp/>matrix<sp/>of<sp/>doubles,<sp/>indices<sp/>start<sp/>at<sp/>1<sp/></highlight></codeline>
<codeline><highlight class="normal">auto<sp/>D<sp/>=<sp/>CMatrix<sp/>&lt;double&gt;<sp/>(10,9,8,7);<sp/>//<sp/>access<sp/>as<sp/>D(i,j,k,l)</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>create<sp/>a<sp/>2D<sp/>view<sp/>of<sp/>a<sp/>standard<sp/>array</highlight></codeline>
<codeline><highlight class="normal">std::array&lt;int,<sp/>9&gt;<sp/>E1d;</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>E<sp/>=<sp/>ViewCArray&lt;int&gt;<sp/>(&amp;E1d[0],<sp/>3,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal">E(0,0)<sp/>=<sp/>1;<sp/><sp/>//<sp/>and<sp/>so<sp/>on</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>create<sp/>a<sp/>ragged-right<sp/>array<sp/>of<sp/>integers</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/>[1,<sp/>2,<sp/>3]</highlight></codeline>
<codeline><highlight class="normal">//<sp/>[4,<sp/>5]</highlight></codeline>
<codeline><highlight class="normal">//<sp/>[6]</highlight></codeline>
<codeline><highlight class="normal">//<sp/>[7,<sp/>8,<sp/>9,<sp/>10]</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>my_strides[4]<sp/>=<sp/>{3,<sp/>2,<sp/>1,<sp/>4};</highlight></codeline>
<codeline><highlight class="normal">RaggedRightArray<sp/>&lt;int&gt;<sp/>ragged(my_strides,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">int<sp/>value<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(int<sp/>i=0;<sp/>i&lt;4;<sp/>i++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>j=0;<sp/>j&lt;my_ragged.stride(i);<sp/>j++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ragged(i,j)<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="index_1autotoc_md4">
<title>Cloning the code</title>
<para>If your SSH keys are set in github, then from the terminal type: <programlisting><codeline><highlight class="normal">git<sp/>clone<sp/>--recursive<sp/>ssh://git@github.com/lanl/MATAR.git<sp/><sp/><sp/><sp/></highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="index_1autotoc_md5">
<title>Basic build</title>
<para>The basic build is for users only interested in the serial CPU only MATAR data types. For this build, we recommend making a folder perhaps called build then go into the build folder and type <programlisting><codeline><highlight class="normal">cmake<sp/>..</highlight></codeline>
<codeline><highlight class="normal">make</highlight></codeline>
</programlisting> The compiled code will be in the build folder.</para>
</sect1>
<sect1 id="index_1autotoc_md6">
<title>Debug basic build</title>
<para>To build serial CPU only MATAR data types in the debug mode, please use <programlisting><codeline><highlight class="normal">cmake<sp/>-DCMAKE_BUILD_TYPE=Debug<sp/>..</highlight></codeline>
<codeline><highlight class="normal">make</highlight></codeline>
</programlisting> The debug flag includes checks on array and matrix dimensions and index bounds.</para>
</sect1>
<sect1 id="index_1autotoc_md7">
<title>Building MATAR with Kokkos</title>
<para>A suite of build scripts are provided to build MATAR with Kokkos for performance portability across computer architectures (CPUs and GPUs). The scripts for various Kokkos backends (e.g., CUDA, HIP, OpenMP, and pthreads) are located within the scripts folder. The provided scripts are configured for particular hardware, the user will likely need to alter the inputs to reflect their hardware. There are three scripts in each folder that are sourced to build MATAR with Kokkos. The scripts are <programlisting><codeline><highlight class="normal">sourceme-env.sh</highlight></codeline>
<codeline><highlight class="normal">kokkos-install.sh</highlight></codeline>
<codeline><highlight class="normal">backend-cmake-build.sh</highlight></codeline>
</programlisting> The word backend denotes cuda, hip, openMP, and so forth. Scripts are also provided to build MATAR without Kokkos, and in that case there is no backend listed since it doesn&apos;t use Kokko. The backend-cmake-build.sh script will run cmake and make for the project. Afterwords, the user can just runs make inside the respective build directory to compile the project. For clarity, running all the scripts is only necessary to set up and compile the code the first time, afterwards, the use can compile the code using make in the build directory. The environment variables will need to be set when logging into a compute node or when changing to a different kokkos backend. For all builds, a single script is provided in each script folder to automate the entire build process, it runs the three aforementioned scripts sequentially. <programlisting><codeline><highlight class="normal">build-it.sh</highlight></codeline>
</programlisting> Before using the build-it.sh script, the user must verify that the settings in the other scripts that build MATAR with a Kokkos backend are correctly set. After running the build-it.sh script, the entire project is compiled and stored in a directory that is named with the respective Kokkos backend e.g., build-kokkos-cuda. Further details are provided on the three scripts to configure and build MATAR with a Kokkos backend.</para>
<sect2 id="index_1autotoc_md8">
<title>Environment configuration script</title>
<para>To start, the environment variables and modules must be configured by sourcing the following script <programlisting><codeline><highlight class="normal">source<sp/>sourceme-env.sh</highlight></codeline>
</programlisting> This script is where the user will load the necessary module files for their given machine/architecture combination. This script also creates the build directory for the project e.g., build-kokkos-cuda, build-kokkos-hip, build-kokkos-openmp, etc.</para>
</sect2>
<sect2 id="index_1autotoc_md9">
<title>Install Kokkos script</title>
<para>The next step is to install Kokkos, using the version that was cloned recursively within MATAR, and configure the Kokkos build for specific hardware and a backend. <linebreak/>
 <programlisting><codeline><highlight class="normal">source<sp/>kokkos-install.sh</highlight></codeline>
</programlisting> Within this script, the user will need to set any Kokkos specific variables for their project. The architecture variables will need to be modified based on the architecture being used. The provided scripts are set for a particular hardware that might differ from what a user might be using. CPU architecture information needs to be listed if running with the Kokkos serial or OpenMP backends; GPU architecture information must be listed if using a Kokkos GPU backend. We refer the user to Kokkos compiling page to see the large list of compilation options, <programlisting><codeline><highlight class="normal">https://github.com/kokkos/kokkos/wiki/Compiling</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1autotoc_md10">
<title>CUDA compilation script</title>
<para>To build the project with cuda, the last step is to type <programlisting><codeline><highlight class="normal">source<sp/>cuda-cmake-build.sh</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1autotoc_md11">
<title>HIP compilation script</title>
<para>To build the project with hip, the last step is to type <programlisting><codeline><highlight class="normal">source<sp/>hip-cmake-build.sh</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1autotoc_md12">
<title>openMP compilation script</title>
<para>To build the project with openMP, the last step is to type</para>
<para><programlisting><codeline><highlight class="normal">source<sp/>openmp-cmake-build.sh</highlight></codeline>
</programlisting> The sourceme-env.sh script (the first step) sets the number of threads to 16 by default. Changing the number of threads used with openMP requires manually setting the environment variable OMP_NUM_THREADS. <linebreak/>
</para>
</sect2>
<sect2 id="index_1autotoc_md13">
<title>pthreads compilation script</title>
<para>To build the project with ptheads, the last step is to type <programlisting><codeline><highlight class="normal">source<sp/>pthreads-cmake-build.sh</highlight></codeline>
</programlisting> To specify number of threads when running a code with the Kokkos pthread backend, add the following command line arguments <programlisting><codeline><highlight class="normal">--kokkos-threads=4</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1autotoc_md14">
<title>Automate build process</title>
<para>A build-it.sh script is provided that runs all scripts sequentially for the user. The build-it.sh script obviates the need to manually source each script. The user must verify the settings are correct in each script prior to using the build-it.sh script. If the build-it.sh script fails to build the project correctly, the user should carefully look at the loaded modules and settings for building Kokkos. <linebreak/>
</para>
</sect2>
</sect1>
<sect1 id="index_1autotoc_md15">
<title>Contributing</title>
<para>Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.</para>
</sect1>
<sect1 id="index_1autotoc_md16">
<title>License</title>
<para>This program is open source under the BSD-3 License.</para>
</sect1>
<sect1 id="index_1autotoc_md17">
<title>Citation</title>
<para><programlisting><codeline><highlight class="normal">@article{MATAR,</highlight></codeline>
<codeline><highlight class="normal">title<sp/>=<sp/>&quot;{MATAR:<sp/>A<sp/>Performance<sp/>Portability<sp/>and<sp/>Productivity<sp/>Implementation<sp/>of<sp/>Data-Oriented<sp/>Design<sp/>with<sp/>Kokkos}&quot;,</highlight></codeline>
<codeline><highlight class="normal">journal<sp/>=<sp/>{Journal<sp/>of<sp/>Parallel<sp/>and<sp/>Distributed<sp/>Computing},</highlight></codeline>
<codeline><highlight class="normal">pages<sp/>=<sp/>{86-104},</highlight></codeline>
<codeline><highlight class="normal">volume<sp/>=<sp/>{157},</highlight></codeline>
<codeline><highlight class="normal">year<sp/>=<sp/>{2021},</highlight></codeline>
<codeline><highlight class="normal">author<sp/>=<sp/>{Daniel<sp/>J.<sp/>Dunning<sp/>and<sp/>Nathaniel<sp/>R.<sp/>Morgan<sp/>and<sp/>Jacob<sp/>L.<sp/>Moore<sp/>and<sp/>Eappen<sp/>Nelluvelil<sp/>and<sp/>Tanya<sp/>V.<sp/>Tafolla<sp/>and<sp/>Robert<sp/>W.<sp/>Robey},</highlight></codeline>
<codeline><highlight class="normal">keywords<sp/>=<sp/>{Performance,<sp/>Portability,<sp/>Productivity,<sp/>Memory<sp/>Efficiency,<sp/>GPUs,<sp/>dense<sp/>and<sp/>sparse<sp/>storage}</highlight></codeline>
</programlisting> </para>
</sect1>
    </detaileddescription>
    <location file="/Users/calvinroth/paraNotes/MATAR/README.md"/>
  </compounddef>
</doxygen>
